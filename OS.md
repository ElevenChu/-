## OS基础
- 操作系统的基本功能

  1 统一管理计算机资源：处理器资源，IO设备资源，存储器资源，文件资源…
   
  2 实现了对计算机资源的抽象：IO设备管理软件提供读写接口，文件管理软件提供操作文件接口…
  
  3 提供了用户与计算机之间的接口：图像窗口形式，命令形式，系统调用形式…
  
- 操作系统的基本特性

a.并发性
   并行：指两个或多个事件可以在同一个时刻发生；
   并发：指两个或多个事件可以在同一个时间间隔发生
   
b.共享性：操作系统的中资源可供多个并发的程序共同使用，这种形式称之为资源共享。
   互斥共享：当资源被程序占用时，其它想使用的程序只能等待。
   同时访问：某种资源并发的被多个程序访问
   
c.虚拟性：表现为把一个物理实体转变为若干个逻辑实体。
   时分复用技术：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。
   空分复用技术：用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。
   
d.异步性：在多道程序环境下，允许多个进程并发执行，但由于资源等因素的限制，使进程的执行以“停停走走”的方式运行，而且每个进程执行的情况（运行、暂停、速度、完成）也是未知的。

## 进程与线程
- 进程： 是系统进行资源分配和调度的一个独立单位，是最小的资源管理单位
- 线程：是进程的一个实体，是 CPU 调度和分派的基本单位，是最小的 CPU 执行单元。线程自己不拥有任何系统资源，但是它可以访问其隶属进程的全部资源。所以线程创建、撤销、切换的开销远小于进程，一个进程可以拥有多个线程
- 进程的五状态模型

  就绪状态：其它资源（进程控制块、内存、栈空间、堆空间等）都准备好、只差CPU的状态。
  
  执行状态：进程获得CPU，其程序正在执行。
  
  阻塞状态：进程因某种原因放弃CPU的状态。
  
  创建状态：创建进程时拥有PCB但其它资源尚未就绪。
  
  终止状态：进程结束由系统清理或者归还PCB的状态。
  
  ![1fcc6cff378c169d786c85a399590d3a_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGVpMzA1,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132977016-576d34d4-d755-4733-85b8-f41227ca3c45.png)


### 区别
- Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

- Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

- Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

- Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。


### 进程与线程同步的方法

- 进程同步的方法：消息队列，共享存储，信号量
- 线程同步的方法：互斥量，读写锁，自旋锁，条件变量

## 操作系统64位和32位的区别
- 1、运行能力不同。64位可以一次性可以处理8个字节的数据量，而32位一次性只可以处理4个字节的数据量，因此64位比32位的运行能力提高了一倍。
- 2、内存寻址不同。64位最大寻址空间为2的64次方，理论值直接达到了16TB，而32位的最大寻址空间为2的32次方，为4GB，换而言之，就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数。   
- 3、运行软件不同。由于32位和64位CPU的指令集是不同的。所以需要区分32位和64位版本的软件。
为了保证兼容性，64位CPU上也能运行老的32位指令。于是实际上我们可以在64位CPU上运行32位程序，但是反过来不行。简而言之就是64位的操作系统可以兼容运行32位的软件，反过来32位系统不可以运行64位的软件

## AIO,BIO,NIO
- IO：阻塞IO

- BIO：同步阻塞IO。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器需要启动一个线程进行处理，如果这个链接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。

- NIO：同步非阻塞IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这需要用户进行不停的去询问。NIO的包括三个核心概念:缓冲区(Buffer)、通道(Channel)、选择器(Selector)。如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作

- AIO：Asynchronous IO，异步非阻塞AIO。最大的特性时具有异步能力，这种能力对socket与文件I/O都起作用。AIO其实是一种在读写操作结束之前允许进行其他操作的I/O处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。

- NIO和IO的主要区别

![image](https://user-images.githubusercontent.com/57619422/132968061-d9cee887-4279-4f01-a172-f2641027e5a3.png)
- BIO，NIO，AIO对比
![image](https://user-images.githubusercontent.com/57619422/132968067-b6e18d00-de4c-476c-aa63-b7eb2ce4b0b7.png)

- 各自使用场景

1.BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

2.NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

3.AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

## 存储管理
- 内存分配的过程
内存分配的过程：单一连续分配、固定分区分配、动态分区分配（根据实际需要，动态的分配内存）。

- 动态分区分配算法
首次适应算法：分配内存时，从开始顺序查找适合内存区，若无合适内存区，则分配失败。

最佳适应算法：要求空闲区链表按照容量大小排序，遍历以找到最佳适合的空闲区。
   
快速适应算法：要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区。
   


- 你怎么理解操作系统里的内存碎片，有什么解决办法?
内存碎片通常分为内部碎片和外部碎片：

1. 内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就会产生内部碎片，通常内部碎片难以完全避免；
    
2.外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。
    
现在普遍采取的内存分配方式是段页式内存分配。将内存分为不同的段，再将每一段分成固定大小的页。通过页表机制，使段内的页可以不必连续处于同一内存区域。

### 段页式存储管理
- 什么是页式存储？
 将进程逻辑空间等分成若干大小的页面，相应的把物理内存空间分成与页面大小的物理块，以页面为单位把进程空间装进物理内存中分散的物理块
 
主存被等分成大小相等的片，称为主存块，又称为实页。

当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为2的n次方 ,通常为1KB、2KB、2n KB等

- 什么是段式存储管理
将进程逻辑空间分成若干段（不等分），段的长度由连续逻辑的长度决定

-区别
![04e96623410327e2ce3f5c638b479ec6_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGVpMzA1,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132977853-4ced90e9-ebf0-416a-bc84-45b3de0eaa2a.png)

### 线程同步的方法
1.互斥锁

互斥锁是最简单的线程同步的方法，也称为互斥量，处于两态之一的变量：解锁和加锁，两个状态可以保证资源访问的串行

原子性：指一系列操作不可被中断的特性，要么全部执行完成，要么全部没有执行。

![39998d1095f0f90d0da634e312aa89aa_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGVpMzA1,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132979751-ac90317c-795a-44ef-879b-f5fec4d6296c.png)

2.自旋锁

自旋锁是一种多线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用，自旋锁不会让出CPU，是一种忙等待状态，即死循环等待锁被释放

特点：避免了进程或者线程上下文切换的开销，但是不适合在单核CPU使用
![dc57de512abcfe890c39b9837659105d_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGVpMzA1,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132979773-52a80d51-afa0-4328-a886-b6ce434aedd6.png)

3.读写锁

是一种特殊的自旋锁，允许多个读操作同时访问资源以提高读性能，但是对写操作是互斥的，即对多读少写的操作效率提升很显著
![fad320bed2d6cbfa239c0154f718c224_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGVpMzA1,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132979786-5f626c2e-d846-46a5-96f2-4fc24e3254bc.png)

4.条件变量
是一种相对比较复杂的线程同步方法，条件变量允许线程睡眠，直到满足某种条件，当满足条件时，可以给该线程信号通知唤醒。

  例如，在生产者-消费者问题当中，规定当缓冲区小于等于时，不允许消费者消费，消费者必须等待；缓冲区满时，不允许生产者往缓冲区生产，生产者必须等待；即当生产者生产一个产品时，唤醒可能等待的消费者，当消费者消费一个产品时，唤醒可能等待的生产者。

5.线程同步方法总结
![2ca8e31a6207cd7ffdd89b211e9c8fb5_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGVpMzA1,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132979813-25e8b6d2-dbd5-47fe-971f-bfeb1ade26e6.png)

### 进程同步
- 1.使用fork系统调用创建进程
  使用fork系统调用无参数，fork会返回两次，分别返回子进程id和0，返回子进程id的是父进程，返回0的是子进程。
- 2.共享内存
  在某种程度上，多进程是共同使用物理内存的，但是由于操作系统的进程管理，进程间的内存空间是独立的，因此进程默认是不能访问进程空间之外的内存空间的。
  
  共享存储允许不相关的进程访问同一片物理内存，共享内存是两个进程之间共享和传递数据最快的方式，但是共享内存未提供同步机制，所以需要借助其它机制管理访问。即共享内存是高性能后台开发中最常用的进程同步方式。

- 3.Unix域套接字
  域套接字是一种高级的进程间通信的方法，可以用于同一机器进程间通信。
  
  套接字（socket）：为网络通信中使用的术语。
  
  Unix系统提供的域套接字提供了网络套接字类似的功能，如Nfinx、uWSGI等。
  
  服务端和客户端分别使用Unix域套接字的过程
  ![668b056678d89d7befbebb8a0bb6c031_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGVpMzA1,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132980251-f73d2c07-df1b-4c86-8693-518b90679d60.png)
  

### 线程池

线程池：线程池是存放多个线程的容器，CPU调度线程执行后不会销毁线程，将线程放回线程池重新利用。

使用线程池的原因：当new一个线程这个方法被调用频繁时就会创建很多线程，不仅会消耗系统资源，还会降低系统的稳定性.

1.降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。

2.提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

3.增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控


- 核心参数
- ![image](https://user-images.githubusercontent.com/57619422/132981461-64b15882-b2e2-4950-90bf-dd64e6cb425e.png)

![image](https://user-images.githubusercontent.com/57619422/132981427-71253c40-07da-4949-b507-f914cf68299a.png)


- 线程池的五个状态
![image](https://user-images.githubusercontent.com/57619422/132981476-7d0ae3fc-5844-4698-a60f-f72ae67d7e31.png)

- 运行过程
![image](https://user-images.githubusercontent.com/57619422/132981498-d9c36189-d51e-417d-96ef-e0edfbe12615.png)

- 常见的阻塞队列（BlockQueue）
![2d78fe92c3919bd7c456d96148ffca4e_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX0hvdTIwMTY=,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132981529-1d7f38e7-4bdd-47bb-91eb-e4bb76493f79.png)

- 线程池有哪些拒绝策略
![image](https://user-images.githubusercontent.com/57619422/132981571-b9433e4a-59f0-406e-9c72-a1213115522c.png)

- 核心线程怎么实现一直存活？
- 
:核心线程在获取任务时，通过阻塞队列的 take() 方法实现的一直阻塞（存活）

- 非核心线程如何实现在 keepAliveTime 后死亡

:原理同上，也是利用阻塞队列的方法，在获取任务时通过阻塞队列的 poll(time,unit) 方法实现的在延迟死亡。

- 非核心线程能成为核心线程吗?
:虽然我们一直讲着核心线程和非核心线程，但是其实线程池内部是不区分核心线程和非核心线程的。只是根据当前线程池的工作线程数来进行调整，因此看起来像是有核心线程于非核心线程

- 如何终止线程池?

:1 shutdown：“温柔”的关闭线程池。不接受新任务，但是在关闭前会将之前提交的任务处理完毕。

2 shutdownNow：“粗暴”的关闭线程池，也就是直接关闭线程池，通过 Thread#interrupt() 方法终止所有线程，不会等待之前提交的任务执行完毕。但是会返回队列中未处理的任务。

- Executors 提供了哪些创建线程池的方法？
![image](https://user-images.githubusercontent.com/57619422/132981783-2293a235-81eb-42af-89eb-c1b5ded65d8b.png)

- 线程池里有个 ctl，你知道它是如何设计的吗？
:ctl 是一个打包两个概念字段的原子整数。

1）workerCount：指示线程的有效数量；

2）runState：指示线程池的运行状态，有 RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED 等状态。
![image](https://user-images.githubusercontent.com/57619422/132981813-b007dcc2-197f-443b-b18f-d943ef2fb738.png)

- ctl为什么这么设计？有什么好处吗？
:![image](https://user-images.githubusercontent.com/57619422/132981852-f9b2d8b7-26e5-4ca3-aa94-2034cefbedb9.png)

- 在我们实际使用中，线程池的大小配置多少合适？
![image](https://user-images.githubusercontent.com/57619422/132981878-15f54329-253a-4fc7-94f6-5ca24409295b.png)

## 处理调度与死锁
- 请谈一谈，系统如何提高并发性
1、提高CPU并发计算能力

（1）多进程&多线程

（2）减少进程切换，使用线程，考虑进程绑定CPU

（3）减少使用不必要的锁，考虑无锁编程

（4）考虑进程优先级

（5）关注系统负载

2、改进I/O模型

(1)DMA技术

(2)异步I/O

(3)改进多路I/O就绪通知策略，epoll

(4)Sendfile

(5)内存映射

(6)直接I/O

## 死锁
:是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

- 死锁的四个必要条件

互斥条件：进程对资源的使用是排他性使用，某资源只能由一个进程使用，其它进程需要使用只能等待。

请求保持条件：进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞的进程不释放自己保持的资源。
   
不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺（包括OS），只能由进程自身释放。
   
环路等待条件：发生死锁时，必然存在进程-资源环形链.

- 死锁的处理

预防死锁的方法：破坏四个必要条件的中一个或多个。

    破坏请求保持条件：系统规定进程运行之前，一次性申请所有需要的资源。
    
    破坏不可剥夺条件：当一个进程请求新的资源得不到满足时，必须释放占有的资源。
    
    破坏环路等待条件：可用资源线性排序，申请必须按照需要递增申请。
    
  银行家算法：客户申请的贷款是有限的，每次申请需要申明最大资金量，银行家在能够满足贷款时，都应该给用户贷款，客户在使用贷款后，能够及时归还贷款。
  
  银行家算法原理:当有一个进程请求各种资源时, 银行家算法会根据当前系统情况给你返回一个如果分配给你的话系统处于安全状态还是unsafe(不安全状态)的结果, 如果返回safe, 那么就会分配给你, 如果返回unsafe, 那么请求进程就需要阻塞等待.
![02f6c00c69ebac21de40b1d30d34c0f4_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI0NTM3NQ==,size_16,color_FFFFFF,t_70](https://user-images.githubusercontent.com/57619422/132977458-ea45dc3f-0c6c-4d58-8e8d-a91a12c4ef28.png)


